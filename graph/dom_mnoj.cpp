#include <bits/stdc++.h>

using namespace std;
/*Винни-Пух и Пятачок нанялись защищать компьютерную сеть от хаккеров, которые выкачивали из компьютеров секретную информацию. Компьютерная сеть Винни-Пуха и Пятачка состояла из связанных между собой больших ЭВМ, к каждой из которых подключалось несколько терминалов. Подключение к одной из больших ЭВМ позволяло получить информацию, содержащуюся в памяти этой ЭВМ, а также всю информацию, доступную для ЭВМ, к которым данная ЭВМ могла направлять запросы. Хаккеры и раньше нападали на подобные компьютерные сети и их тактика была известна. Поэтому Винни-Пух и Пятачок разработали специальную программу, которая помогла принять меры против готовившегося нападения.

Тактика хаккеров.
При нападениях хаккеры всегда получают доступ к информации всех ЭВМ сети. Добиваются они этого, захватывая некоторые ЭВМ сети, так чтобы от них можно было запросить информацию у оставшихся ЭВМ. Вариантов захвата существует множество. Например, захватить все ЭВМ. Но хаккеры всегда выбирают такой вариант, при котором суммарное количество терминалов у захваченных ЭВМ минимально.

Примечание.
В сети Винни-Пуха и Пяточка ни у каких 2-х ЭВМ количество терминалов не совпадает.

Техническое задание.
Вам необходимо написать программу, входными данными которой было бы описание сети, а выходными - список номеров ЭВМ, которые могут быть выбраны хаккерами для захвата сети согласно их тактике.

Формат ввода.
N  (Количество ЭВМ в сети )
T[1]    (ЭВМ #1 имеет терминалов)
T[2]    (ЭВМ #2 имеет терминалов) 
  ...
T[N]    (ЭВМ #N имеет терминалов)
A[1]  B[1]  (Права на запрос)
A[2]  B[2]
  ...
A[K]  B[K]
 0    0
A[i] и В[i] - номера ЭВМ, последняя строка '0 0' обозначает конец списка прав на запрос, каждая пара A[i] B[i] обозначает, что ЭВМ с номеров A[i] имеет право запрашивать информацию у ЭВМ с номером B[i] (A[i] не равно B[i]).

При вводе числа N и T[i] - натуральные, T[i] <=1000, N<=50, K<=2450.

Входные данные соответствуют приведенным условиям.




5
100
2
1
3
10
1 3
3 2
4 3
4 5
5 4
0 0




1 4
2
*/
vector<vector<int>>gr;
vector<int>v;
int sm =0;
void dfs(int vr) {
    sm++;
    v[vr] = 1;
    for(int i = 0; i < gr[vr].size(); i++){
        if(!v[gr[vr][i]]){
            dfs(gr[vr][i]);
        }
    }
}

int main(){
    freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);
    int n, m;
    cin >> n;
    gr.resize(n + 1);
    v.resize(n + 1, 0);
    int a[n+1],b[n+1],c[n+1];
    for(int i =1;i<=n;i++){
        cin >> a[i];
        b[i] = i;
    }
    for(int i = 0; i < 2500; i++){
        int first, second;
        cin >> first >> second;
        if(first == 0 && second == 0)break;
        gr[first].push_back(second);
    }
    for(int i =1;i<n;i++){
        for(int j =i+1;j<n+1;j++){
            if(a[i]>a[j]){
                swap(a[i],a[j]);
                swap(b[i],b[j]);
            }
        }
    }
    for(int i =1;i<n+1;i++){
        sm =0;
        dfs(b[i]);
        c[i] = sm;
        for(int j =1;j<n+1;j++){
            v[j] = 0;
        }
    }
    for(int i =1;i<n;i++){
        for(int j =i+1;j<n+1;j++){
            if(c[i]<c[j]){
                swap(a[i],a[j]);
                swap(b[i],b[j]);
                swap(c[i],c[j]);
            }
        }
    }
    sm =0;
    int k =0;
    vector<int> u;
    for(int i =1;i<n+1;i++){
        if(v[b[i]]==0){
            k++;
            dfs(b[i]);
            u.push_back(b[i]);
        }
        if(sm == n)break;
    }
    sort(u.begin(),u.end());
    for(int i =0;i<u.size();i++){
        cout << u[i] << " ";
    }
    cout << endl << k;

 /*
    for(int i =1;i<n+1;i++){
        cout << b[i] << " " << c[i] << "     " << a[i] << endl;
    }
 */

}



/*
    freopen("br1.in","r",stdin);
    freopen("br1.out","w",stdout);
*/
